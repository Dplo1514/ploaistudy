# -*- coding: utf-8 -*-
"""210820 데이터분석 pandas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZTxg3sU8-mhNDu-ivv323nZn5B_nSE7C

![image.png](attachment:image.png)

# pandas

- 파이썬 프로그래밍 언어를 위한 데이터 분석 도구 
- 고성능, 사용하기 쉬운 데이터 구조 제공

## ⏣ 설치
"""

!pip install pandas

"""## ⏣ 임포트"""

import pandas as pd

"""## ⏣ 시리즈(Series)"""

s = pd.Series([990342 , 3448737 , 2890415 , 2466052],
              index=["서울" , "부산", "인천" , "대구"])
s

s.values , s.index

s[0:3] #s."부산" s.1등으로 인덱싱이 가능

"울산" in s

for key, value in s.items(): 
  print(f'{key}시 인구는 {value}명 입니다.')

s[ (2500000 < s) & (s > 500000)]  # 인구가 250만 초과, 500만 미만인 경우

s2=pd.Series({"서울" : 990342 , "부산" : 3448737 , "인천" : 2890415 ,"대구" : 2466052}) #dict를 이용한 시리즈 생성
s2

s2=pd.Series({"서울" : 990342 , "부산" : 3448737 , "인천" : 2890415 ,"대구" : 2466052} , #순서바꾸기
             index=["부산" , "서울" ,"인천" ,"대구"])
s2

print(s)
s2=pd.Series({"서울" : 9564312 , "부산" : 2448737 , "인천" : 2340415 ,"대전" : 1266052} , 
             index=["부산" , "서울" ,"인천" ,"대전"])
s2

ds= s - s2
ds

s.values

s2.values

s.values - s2.values

ds

ds.notnull() #data의 NaN여부로 boolean 형태로 보여주는 메서드

ds[ds.notnull()] #data의 NaN여부로 True , False를 확인 True만 슬라이싱

print(s) #series에 경주 추가
s["경주"] = 1238765 
s

"print(s)
s["경주"] = 111111
s

del.s["경주"]
s





















"""## ⏣ 데이터프레임(DataFrame)"""

data = {
    "2015" : [4335 , 3238 , 6327 , 3433],
    "2010" : [6462 , 1535 , 1231 , 4576],
    "2005" : [9008 , 9345 , 2389 , 3478],
    "지역" : ["수도권" , "경상권" ,"수도권" , "경상권"],
    "2010-2015 증가율" : [0.0214 , 0.0125 , 0.1256 , 0.2561]
 }
cols = ["지역" , "2015" , "2010" , "2005" , "2010-2015 증가율"]
rows = ["서울" , "부산" , "인천" , "대구"]
df = pd.DataFrame (data, index=rows , columns=cols)
df

df["2015"]

df[["2015" , "2005"]]

df[:1]



# "2010-2015 증가율"이라는 이름의 열 수정

# "2005-2010 증가율"이라는 이름의 열 추가

# "2010-2015 증가율"이라는 이름의 열 삭제

# 하나의 열만 인덱싱하면 시리즈가 반환된다.

# 여러개의 열을 인덱싱하면 부분적인 데이터프레임이 반환된다.

# 2010이라는 열을 반환하면서 데이터프레임 자료형을 유지



# 2010이라는 열을 반환하면서 시리즈 자료형으로 변환











import numpy as np

df= pd.DataFrame(np.arange (10,22).reshape(3,4),
                 index = ["a","b","c"],
                 columns = ["A","B","C","D"])
df

df.loc["b":"c"]

df.loc[["a","c"]]

df.A > 15

df.loc[df.A > 15]

df.loc["a" , "A"]

df.loc["a":"b","A":"C"]

df.loc["a":"b",["A","C"]]

df.loc[0:1,[1:2]]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile sample1.csv
# c1 , c2 , c3
# 1, 1.11 , one
# 2, 2.22 , two
# 3, 3.33 , three

df2 = pd.read_csv('sample2.csv' , names=["c1","c2","c3"])

df2.index= ["a1" , "a2" , "a3"]
df2

df

df.to_csv('sample3.csv')

df3 = pd.read_csv('sample3.csv' , index_col = 0)
df3

df.to_csv('sample3.csv' , index=False , header=False)

df4 = pd.read_csv("https://raw.githubusercontent.com/datascienceschool/docker_rpython/master/data/titanic.csv")
df4

df4.head(10)

df4.tail(10)













# url : https://raw.githubusercontent.com/datascienceschool/docker_rpython/master/data/titanic.csv



